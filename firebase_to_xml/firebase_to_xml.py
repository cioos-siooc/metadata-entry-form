import traceback
from google.oauth2 import service_account
from google.auth.transport.requests import AuthorizedSession
import json
import os
import sys
import getopt
import pathlib
import pprint
import yaml
from metadata_xml.template_functions import metadata_to_xml
from jinja2 import Environment, FileSystemLoader
import argparse
from dotenv import load_dotenv


def main(argv):

    load_dotenv()

    parser = argparse.ArgumentParser(description='Convert firebase metadata form to xml and optionaly yaml')
    parser.add_argument('-k', '--key', nargs='?', default=os.getenv("FIREBASE_OAUTH2_KEY"),
                        help='name and path of json google OAuth2 key file generated by a service account')
    parser.add_argument('-o', '--out', nargs='?', default=os.getenv("FIREBASE_OUTPUT_FOLDER")or '',
                        help='folder to output the created xml files to')
    parser.add_argument('-y', '--yaml', action='store_true', default=os.getenv("FIREBASE_OUTPUT_YAML") or False,
                        help='output yaml file as well as xml')
    parser.add_argument('-ra', '--RA', nargs='?', default=os.getenv("FIREBASE_RA") or 'test',
                        help='Set the RA forms will be converted for (atlantic, pacific, stlaurent)')
    args = vars(parser.parse_args())

    # Authenticate with Firebase

    # Define the required scopes
    scopes = [
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/firebase.database"
    ]

    # Authenticate a credential with the service account
    credentials = service_account.Credentials.from_service_account_file(
        args['key'], scopes=scopes)

    # Use the credentials object to authenticate a Requests session.
    authed_session = AuthorizedSession(credentials)
    # request data
    response = authed_session.get(
        f'https://cioos-metadata-form.firebaseio.com/{args["RA"]}/users.json')

    # Parse response
    body = json.loads(response.text)
    if body is None:
        pprint.pprint(json.loads(response))
        print('response body not found. Exiting...')
        sys.exit()

    record_list = []
    for k, v in body.items():
        # if v.get('userinfo',{}).get('email') not in user_list:
        #     continue
        records = v.get('records')
        if not records:
            continue

        for k2, v2 in records.items():
            record_list.append(v2)

    for r in record_list:
        try:
            # Generate dictinary expected by metadata-xml
            yDict = {
                'metadata': {
                    'naming_authority': r.get('namingAuthority'),
                    'identifier': r.get('recordID'),
                    'language': r.get('language'),
                    'maintenance_note': r.get('maintenance'),
                    'use_constraints': {
                        'limitations': r.get('limitations'),
                        'license': r.get('license',)
                        # {title: Creative Commons Attribution 4.0
                        # code: CC-BY-4.0
                        # url: https://creativecommons.org/licenses/by/4.0/}
                    },
                    'comment': r.get('comment'),
                    'history': r.get('history'),  # {'en':'','fr':''}
                },
                'spatial': {
                    'bbox': [r.get('map', {}).get('west'),
                             r.get('map', {}).get('south'),
                             r.get('map', {}).get('east'),
                             r.get('map', {}).get('north')],
                    'polygon': r.get('map', {}).get('polygon'),
                    'vertical': [r.get('verticalExtentMin'), r.get('verticalExtentMax')],
                },
                'identification': {
                    'title': r.get('title'),  # {'en':'','fr':''}
                    'abstract': r.get('abstract'),  # {'en':'','fr':''}
                    'dates': {},  # filled out later
                    'keywords': {
                        'default': r.get('keywords', {'en': [], 'fr': []}),
                        'eov': r.get('eov')
                    },
                    'temporal_begin': r.get('dateStart'),
                    'temporal_end': r.get('dateEnd', 'now'),
                    # temporal_duration: P1D
                    # time_coverage_resolution: P1D
                    # acknowledgement: acknowledgement
                    'status': r.get('status'),
                    # project: # {'en':[''],'fr':['']}
                },
                'contact': [
                    {
                        'roles': [x.get('role')],
                        'organization':{
                            'name': x.get('orgName'),
                            'url': x.get('orgURL'),
                            'address': x.get('orgAdress'),
                            'city': x.get('orgCity'),
                            'country': x.get('orgCountry'),
                            'email': x.get('orgEmail')
                        },
                        'individual': {
                            'name': x.get('indName'),
                            'position': x.get('indPosition'),
                            'email': x.get('indEmail'),
                            # country:
                        }
                    } for x in r.get('contacts', [])
                ],

                'distribution': [
                    {
                        'url': [x.get('url')],
                        'name': x.get('name'),
                        'description': x.get('description'),  # {'en':'','fr':''}
                    } for x in r.get('distribution', [])
                ],
                'platform': {
                    'name': r.get('platformName'),
                    'role': r.get('platformRole'),
                    'authority': r.get('platformAuthority'),
                    'id': r.get('platformID'),
                    'description': r.get('platformDescription'),
                    'instruments': r.get('instruments',[]),
                    # [{'id': '123'
                    #   'manufacturer': 'manufacturer en 1'
                    #   'version': 'A1.53'
                    #   'type': {'en':'','fr':''}
                    #   'description': {'en':'','fr':''}}]
                }
            }

            if r.get('dateStart') is not None:
                yDict['identification']['dates']['creation'] = r.get('dateStart') or r.get('created')
            if r.get('datePublished') is not None:
                yDict['identification']['dates']['publication'] = r.get(
                    'datePublished')
            if r.get('dateRevised') is not None:
                yDict['identification']['dates']['revision'] = r.get('dateRevised')

            # TODO: the following checks would be better done by validation module of some sort

            # check at least one date has been added otherwise skip this record
            if not yDict.get('identification') or not yDict.get('identification').get('dates'):
                raise Exception(
                    'at least one entry in identification.dates is required')

            # check keywords exists
            if not yDict['identification'] \
                    or not yDict['identification']['keywords'] \
                    or not yDict['identification']['keywords']['eov']:
                raise Exception(
                    'at least one entry in identification.keywords.eov is required')

            # output yaml
            if args['yaml']:
                filename = f'{args["out"]}/{name}.yaml'
                file = open(filename, "w")
                file.write(yaml.dump(yDict))

            # render xml template and write to file
            xml = metadata_to_xml(yDict)
            name = r['title'][r['language']]
            if name:
                char_list = [character if character.isalnum() else '_' for character in name.strip().lower()]
                name = "".join(char_list)

            filename = f'{args["out"]}/{name}.xml'
            file = open(filename, "w")
            file.write(xml)
            print("Wrote " + file.name)

        except Exception as e:
            # print(e)
            print(traceback.format_exc())


if __name__ == "__main__":
    main(sys.argv[1:])
