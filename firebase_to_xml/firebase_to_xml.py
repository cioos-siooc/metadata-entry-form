import traceback
from google.oauth2 import service_account
from google.auth.transport.requests import AuthorizedSession
import json
import os
import sys
import getopt
import pathlib
import pprint
from metadata_xml.template_functions import metadata_to_xml
from jinja2 import Environment, FileSystemLoader

from dotenv import load_dotenv


def main(argv):


    load_dotenv()

    # Load settings from .env file
    key_file = os.getenv("FIREBASE_OAUTH2_KEY")
    outputfolder = os.getenv("FIREBASE_OUTPUT_FOLDER")
    # RA = os.getenv("FIREBASE_RA")
    # user_list = os.getenv("FIREBASE_USER_LIST").split()

    # load settings from command line
    try:
        opts, args = getopt.getopt(argv, "hk:o:", ["key=", "out="])
    except getopt.GetoptError:
        print('firebase_to_xml.py -k <keyfile> -o <outputfolder>')
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print('''
    firebase_to_xml.py -k <keyfile> -o <outputfolder>

    -k, --key: name and path of json google OAuth2 key file generated by a service account
    -i, --out: folder to output the created xml files to
''')
            sys.exit()
        elif opt in ("-k", "--key"):
            key_file = arg
        elif opt in ("-o", "--out"):
            outputfolder = arg

    # Authenticate with Firebase

    # Define the required scopes
    scopes = [
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/firebase.database"
    ]

    print(key_file)

    # Authenticate a credential with the service account
    credentials = service_account.Credentials.from_service_account_file(
        key_file, scopes=scopes)

    # Use the credentials object to authenticate a Requests session.
    authed_session = AuthorizedSession(credentials)
    # request data
    response = authed_session.get(
        "https://cioos-metadata-form.firebaseio.com/test/users.json")

    # Parse response
    body = json.loads(response.text)
    record_list = []
    for k, v in body.items():
        # if v.get('userinfo',{}).get('email') not in user_list:
        #     continue
        records = v.get('records')
        if not records:
            continue

        for k2, v2 in records.items():
            # if v2.get('RA') != RA:
            #     continue
            record_list.append(v2)

    for r in record_list:
        try:
            # Generate dictinary expected by metadata-xml
            yDict = {
                'metadata': {
                    # {'en':'','fr':''}
                    'naming_authority': r.get('namingAuthority'),
                    'identifier': r.get('recordID'),
                    'language': r.get('language'),
                    'maintenance_note': r.get('maintenance'),
                    'use_constraints': {
                        'limitations': r.get('limitations'),
                        'license': r.get('license',)
                        # {title: Creative Commons Attribution 4.0
                        # code: CC-BY-4.0
                        # url: https://creativecommons.org/licenses/by/4.0/}
                    },
                    'comment': r.get('comment'),
                    'history': r.get('history'),  # {'en':'','fr':''}
                },
                'spatial': {
                    'bbox': [r.get('map', {}).get('west'),
                             r.get('map', {}).get('south'),
                             r.get('map', {}).get('east'),
                             r.get('map', {}).get('north')],
                    # 'polygon': '',
                    # vertical: [0, 10]
                },
                'identification': {
                    'title': r.get('title'),  # {'en':'','fr':''}
                    'abstract': r.get('abstract'),  # {'en':'','fr':''}
                    'dates': {},  # filled out later
                    'keywords': {
                        'default': {
                            'en': [],
                            'fr': []},
                        'eov': r.get('eov')
                    },
                    'temporal_begin': r.get('dateStart'),
                    'temporal_end': r.get('dateEnd', 'now'),
                    # temporal_duration: P1D
                    # time_coverage_resolution: P1D
                    # acknowledgement: acknowledgement
                    'status': r.get('status'),
                    # project: # {'en':[''],'fr':['']}
                },
                'contact': [
                    {
                        'roles': [x.get('role')],
                        'organization':{
                            'name': x.get('orgName'),
                            'url': x.get('orgURL'),
                            'address': x.get('orgAdress'),
                            'city': x.get('orgCity'),
                            'country': x.get('orgCountry'),
                            'email': x.get('orgEmail')
                        },
                        'individual': {
                            'name': x.get('indName'),
                            'position': x.get('indPosition'),
                            'email': x.get('indEmail'),
                            # country:
                        }
                    } for x in r.get('contacts', [])
                ],

                'distribution': [
                    {
                        'url': [x.get('url')],
                        'name': x.get('name'),
                        'description': x.get('description'),
                        #   en: pdf description in English
                        #   fr: pdf description in French
                    } for x in r.get('distribution', [])
                ],
                'platform': {
                    'name': r.get('platformName'),
                    'role': r.get('platformRole'),
                    # authority: platform_authority
                    'id': r.get('platformID'),
                    'description': r.get('platformDescription'),
                    'instruments': r.get('instruments')
                    # - id: 123
                    #   manufacturer: manufacturer en 1
                    #   version: A1.53
                    #   type:
                    #     en: type en 1
                    #     fr: type fr 1
                    #   description:
                    #     en: instrument description en 1
                    #     fr: instrument description fr 1
                }
            }

            if r.get('created') is not None:
                yDict['identification']['dates']['creation'] = r.get('created')
            if r.get('published') is not None:
                yDict['identification']['dates']['publication'] = r.get(
                    'published')
            if r.get('revised') is not None:
                yDict['identification']['dates']['revision'] = r.get('revised')

            # check at least one date has been added otherwise skip this record
            if not yDict.get('identification') or not yDict.get('identification').get('dates'):
                raise Exception(
                    'at least one entry in identification.dates is required')

            # render xml template and write to file
            xml = metadata_to_xml(yDict)
            id = r.get('recordID')
            name = r.get('title', {}).get(r.get('language'))
            if name:
                name = name.strip().lower().replace(' ', '_')
            filename = f'{outputfolder}/{name or id}.xml'
            file = open(filename, "w")
            file.write(xml)
            print("Wrote " + file.name)

        except Exception as e:
            # print(e)
            print(traceback.format_exc())


if __name__ == "__main__":
    main(sys.argv[1:])
